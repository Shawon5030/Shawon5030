from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager
import time
import random

class FacebookCodeSender:
    def __init__(self):
        self.setup_driver()
        self.wait = WebDriverWait(self.driver, 15)
        
    def setup_driver(self):
        """Setup Chrome driver"""
        options = webdriver.ChromeOptions()
        options.add_argument("--disable-blink-features=AutomationControlled")
        options.add_experimental_option("excludeSwitches", ["enable-automation"])
        options.add_experimental_option('useAutomationExtension', False)
        options.add_argument("--window-size=1920,1080")
        
        self.driver = webdriver.Chrome(
            service=Service(ChromeDriverManager().install()),
            options=options
        )
        self.driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")
        print("‚úÖ Chrome driver started")
    
    def random_delay(self, min_seconds=2, max_seconds=4):
        """Random delay between actions"""
        delay = random.uniform(min_seconds, max_seconds)
        time.sleep(delay)
    
    def handle_multi_account_selection(self):
        """Auto-select first account if multiple accounts found"""
        try:
            # Check for "This is my account" buttons (multiple accounts)
            account_buttons = self.driver.find_elements(By.XPATH, 
                "//a[contains(@class, '_42ft') and contains(text(), 'This is my account')]")
            
            if len(account_buttons) > 1:
                print(f"üîç Found {len(account_buttons)} accounts, selecting first one")
                # Click first "This is my account" button
                account_buttons[0].click()
                time.sleep(3)
                return True
            elif len(account_buttons) == 1:
                print("üîç Found 1 account, selecting it")
                account_buttons[0].click()
                time.sleep(3)
                return True
            
            return False
                
        except Exception as e:
            print(f"‚ö†Ô∏è No multiple accounts found or error: {e}")
            return False
    
    def search_account(self, phone_number):
        """Search account with phone number"""
        try:
            self.driver.get("https://www.facebook.com/login/identify")
            time.sleep(3)
            
            # Enter phone number
            phone_input = self.wait.until(EC.presence_of_element_located((By.ID, "identify_email")))
            phone_input.clear()
            phone_input.send_keys(phone_number)
            
            time.sleep(2)
            
            # Click search button
            search_btn = self.wait.until(EC.element_to_be_clickable((By.NAME, "did_submit")))
            search_btn.click()
            
            time.sleep(4)
            
            # ‚úÖ MULTI ACCOUNT HANDLING - AUTO SELECT FIRST ACCOUNT
            self.handle_multi_account_selection()
            
            return True
            
        except Exception as e:
            print(f"‚ùå Search failed: {e}")
            return False
    
    def handle_try_another_way(self):
        """Check and click 'Try another way' if available"""
        try:
            # Check if "Try another way" exists
            try_another_elements = self.driver.find_elements(By.XPATH, 
                "//a[contains(@href, 'tryanotherway') or contains(text(), 'Try another way')]")
            
            if try_another_elements:
                print("üîÑ 'Try another way' found, clicking...")
                try_another_elements[0].click()
                time.sleep(3)
                return True
            return False
            
        except Exception as e:
            print(f"‚ùå Error handling 'Try another way': {e}")
            return False
    
    def select_sms_and_continue(self):
        """Select SMS option and click continue"""
        try:
            # Select SMS option
            sms_selectors = [
                "//input[contains(@id, 'send_sms:')]",
                "//div[contains(text(),'Send code via SMS')]",
                "//span[contains(text(),'Send code via SMS')]"
            ]
            
            sms_found = False
            for selector in sms_selectors:
                try:
                    sms_elements = self.driver.find_elements(By.XPATH, selector)
                    if sms_elements:
                        if "input" in selector:
                            # Click associated label for radio button
                            radio_id = sms_elements[0].get_attribute("id")
                            if radio_id:
                                label = self.driver.find_element(By.XPATH, f"//label[@for='{radio_id}']")
                                label.click()
                        else:
                            sms_elements[0].click()
                        
                        print("üì± SMS option selected")
                        time.sleep(2)
                        sms_found = True
                        break
                except:
                    continue
            
            if not sms_found:
                print("‚ùå SMS option not found")
                return False
            
            # Click continue button
            continue_selectors = [
                "//button[contains(@name, 'reset_action')]",
                "//button[contains(text(),'Continue')]",
                "//input[@value='Continue']"
            ]
            
            continue_found = False
            for selector in continue_selectors:
                try:
                    continue_buttons = self.driver.find_elements(By.XPATH, selector)
                    if continue_buttons:
                        continue_buttons[0].click()
                        print("‚û°Ô∏è Continue clicked")
                        time.sleep(3)
                        continue_found = True
                        break
                except:
                    continue
            
            return continue_found
            
        except Exception as e:
            print(f"‚ùå Error in SMS selection: {e}")
            return False
    
    def check_success(self):
        """Check if code was sent successfully"""
        try:
            success_indicators = [
                "code has been sent",
                "sent to your phone",
                "recovery code", 
                "check your phone"
            ]
            
            page_text = self.driver.page_source.lower()
            if any(indicator in page_text for indicator in success_indicators):
                return True
            return False
        except:
            return False
    
    def process_number(self, phone_number):
        """Main function to process a single number"""
        print(f"\nüîπ Processing: {phone_number}")
        
        try:
            # Step 1: Search account + Auto select first account if multiple
            if not self.search_account(phone_number):
                return False, "Search failed"
            
            # Step 2: Check and click "Try another way" if available
            self.handle_try_another_way()
            
            # Step 3: Select SMS and click continue
            if not self.select_sms_and_continue():
                return False, "SMS selection failed"
            
            # Step 4: Check if successful
            if self.check_success():
                print(f"‚úÖ Code sent successfully to: {phone_number}")
                return True, "Code sent successfully"
            else:
                print(f"‚ö†Ô∏è Code sending status unclear for: {phone_number}")
                return True, "Attempt made - status unclear"
                
        except Exception as e:
            print(f"‚ùå Error: {e}")
            return False, f"Error: {str(e)}"
    
    def close(self):
        """Close browser"""
        if self.driver:
            self.driver.quit()
            print("üîö Browser closed")

def main():
    """Main function"""
    print("üöÄ Facebook SMS Code Sender")
    print("=" * 40)
    
    # Input phone numbers
    phone_numbers = []
    print("\nEnter phone numbers (one per line, empty line to finish):")
    
    while True:
        number = input().strip()
        if not number:
            break
        phone_numbers.append(number)
    
    if not phone_numbers:
        print("‚ùå No phone numbers provided")
        return
    
    print(f"\nüìã Processing {len(phone_numbers)} numbers")
    
    # Initialize sender
    sender = FacebookCodeSender()
    
    try:
        # Process each number
        for i, number in enumerate(phone_numbers, 1):
            print(f"\nüìä Progress: {i}/{len(phone_numbers)}")
            
            success, message = sender.process_number(number)
            
            if success:
                print(f"‚úÖ SUCCESS - {number}")
            else:
                print(f"‚ùå FAILED - {number} - {message}")
            
            # Wait 3 seconds before next number
            if i < len(phone_numbers):
                print("‚è≥ Waiting 3 seconds...")
                time.sleep(3)
        
        print("\nüéâ All numbers processed!")
        
    except KeyboardInterrupt:
        print("\n‚èπÔ∏è Process stopped by user")
    except Exception as e:
        print(f"\n‚ùå Error: {e}")
    finally:
        sender.close()

if __name__ == "__main__":
    main()
